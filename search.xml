<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[云服务器安装远程ipython notebook]]></title>
    <url>%2F2018%2F09%2F28%2F%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E8%BF%9C%E7%A8%8Bipython-notebook%2F</url>
    <content type="text"><![CDATA[Ipython Notebook非常适合用来做数据分析，在windows下安装anaconda就可以直接使用Ipython Notebook了。但是如果是要在云服务器的Linux环境下安装Ipython Notebook，并且在本地远程访问，就需要自己动手配置了。 环境服务器：阿里云ECS，Ubuntu16.04 64位 Xshell5 1.安装anacondaAnaconda指的是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。 首先在清华大学开源软件镜像站下载Anaconda3，下载最新版本就行了 12sudo apt-get update #执行这条命令更新一下sudo wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.2.0-Linux-x86_64.sh #这里我选择的版本是3-5.2.0，64位。 下载好后，进入下载的anaconda 安装包的目录下进行安装 1bash Anaconda3-5.2.0-Linux-x86_64.sh 最后一部是询问是否将python加入环境变量，选择yes，当然你也可以在安装完后手动添加到bash中。 安装完成之后要重启终端，anaconda才能生效。 输入python进行测试安装是否成功，显示python版本这表示安装正确。 2. 配置ipython jupyter2.1.生成配置文件123456789101112131415# 生成配置文件jupyter notebook --generate-config# 此时生成配置文件：# Writing default config to: /home/python/.jupyter/jupyter_notebook_config.py# 这里 /home/python/... 中的python指的是用户名是python，将其改成自己的用户名就好了，下面的情况也是一样的。# 创建登录密码# 打开ipython，生成密钥，这一步也可以不做，如果不需要设置密码的话。$ ipythonfrom notebook.auth import passwdpasswd()Enter password:Verify password:Out[2]: 'sha1:6f6193fcfbd5:614c4ba185334868fc8bbce2e9890b3ef7d1a79b' # 我这里创建的密码是123456，对应的密钥是sha1xxxx的那一串# 然后退出ipython 2.2.创建自签名的证书这一步使用openssl创建一个自签名证书，如果不担心安全问题，不使用ssl速度会快一些。 1234567891011# # 在linux下执行，遇到询问的地方一路回车即可openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem# 会在当前文件夹下生成 mycert.pem，我将它移到.jupyter/secret文件夹下面，方便管理# 先创建.secret文件夹cd .jupytermkdir secret # 移动cd ~mv mycert.pem .jupyter/secret/ 2.3.修改配置文件123456789101112131415161718192021# 打开刚才创建的.jupyter/jupyter_notebook_config.py，先备份源文件，然后再修改# 备份$ cp .jupyter/jupyter_notebook_config.py .jupyter/jupyter_notebook_config.py_bak# 修改如下，可以先删除里面的内容添加，也可以修改，或者直接在头部添加，反正里面的原先的内容都是注释掉的：vi /home/python/.jupyter/jupyter_notebook_config.pyc = get_config()# Kernel configc.IPKernelApp.pylab = 'inline' # if you want plotting support alwaysc.NotebookApp.ip = '*' # 就是设置所有ip皆可访问，在144行c.NotebookApp.open_browser = False # 禁止自动打开浏览器# 密钥，在194行。该密钥就是2.1步生成的c.NotebookApp.password = 'sha1:74d233d59da1:50d7ef60a58456e2016dc427547fb42cdd971cea'c.NotebookApp.port = 6868 # 访问端口，在197行# 自签名证书位置，如果不使用ssl，可以不设置c.NotebookNotary.secret_file = '/home/python/.jupyter/secret/mycert.pem'c.NotebookApp.keyfile = '/home/python/.jupyter/.secret/mykey.key'# 设置目录，存放创建的ipython notebook文件c.NotebookApp.notebook_dir = '/home/python/ipython' 3.XShell配置远程访问1234567891011121314# 启动ipython jupyter，不使用ssljupyter notebook# 或者开启ssl# jupyter notebook --certfile=mycert.pem --keyfile mykey.keyjupyter notebook --certfile=/home/zhenyu/.jupyter/secret/mycert.pem# 输出，看倒数第二行，显示的是IP地址和端口号，记下来[I 15:56:59.916 NotebookApp] JupyterLab beta preview extension loaded from /home/python/anaconda3/lib/python3.6/site-packages/jupyterlab[I 15:56:59.916 NotebookApp] JupyterLab application directory is /home/python/anaconda3/share/jupyter/lab[I 15:56:59.921 NotebookApp] Serving notebooks from local directory: /home/python/ipython[I 15:56:59.921 NotebookApp] 0 active kernels[I 15:56:59.921 NotebookApp] The Jupyter Notebook is running at:[I 15:56:59.921 NotebookApp] http://127.0.0.1:6868/[I 15:56:59.921 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation). 这时候退出XShell连接，再打开XShell，进入会话连接属性，添加一条转义规则，就可以在本地window机器上远程访问jupyter notebook使用python进行数据分析了。 打开浏览器，在地址栏输入http://localhost:5858就能远程访问云服务器中的6868端口了。 linux 下安装anacondahttps://blog.csdn.net/u010414589/article/details/51303502 Linux 远程Ipython Notebookhttps://blog.csdn.net/suzyu12345/article/details/51037905 XShell–SSH端口转发https://blog.csdn.net/qq_34039315/article/details/77510923]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>anaconda</tag>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop在云服务器上的安装教程]]></title>
    <url>%2F2018%2F09%2F28%2FHadoop%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[XShell–SSH端口转发https://blog.csdn.net/qq_34039315/article/details/77510923 修改Linux终端命令行中的用户名和主机名https://blog.csdn.net/qingdu007/article/details/51434172 本教程转载自厦门大学数据库实验室 / 给力星 环境本教程使用 Ubuntu 14.04 64位 作为系统环境（Ubuntu 12.04，Ubuntu16.04 也行，32位、64位均可），请自行安装系统（可参考使用VirtualBox安装Ubuntu）。 如果用的是 CentOS/RedHat 系统，请查看相应的CentOS安装Hadoop教程_单机伪分布式配置。 本教程基于原生 Hadoop 2，在 Hadoop 2.6.0 (stable) 版本下验证通过，可适合任何 Hadoop 2.x.y 版本，如 Hadoop 2.7.1、2.6.3、2.4.1等。 使用本教程请确保系统处于联网状态下，部分高校使用星网锐捷连接网络，可能导致虚拟机无法联网，那么建议您使用双系统安装ubuntu,然后再使用本教程！ Hadoop版本 Hadoop 有两个主要版本，Hadoop 1.x.y 和 Hadoop 2.x.y 系列，比较老的教材上用的可能是 0.20 这样的版本。Hadoop 2.x 版本在不断更新，本教程均可适用。如果需安装 0.20，1.2.1这样的版本，本教程也可以作为参考，主要差别在于配置项，配置请参考官网教程或其他教程。 新版是兼容旧版的，书上旧版本的代码应该能够正常运行（我自己没验证，欢迎验证反馈）。 装好了 Ubuntu 系统之后，在安装 Hadoop 前还需要做一些必备工作。 创建hadoop用户如果你安装 Ubuntu 的时候不是用的 “hadoop” 用户，那么需要增加一个名为 hadoop 的用户。 首先按 ctrl+alt+t 打开终端窗口，输入如下命令创建新用户 : 1sudo useradd -m hadoop -s /bin/bash Shell 命令 这条命令创建了可以登陆的 hadoop 用户，并使用 /bin/bash 作为 shell。 sudo命令 本文中会大量使用到sudo命令。sudo是ubuntu中一种权限管理机制，管理员可以授权给一些普通用户去执行一些需要root权限执行的操作。当使用sudo命令时，就需要输入您当前用户的密码. 密码 在Linux的终端中输入密码，终端是不会显示任何你当前输入的密码，也不会提示你已经输入了多少字符密码。而在windows系统中,输入密码一般都会以“*”表示你输入的密码字符 输入法中英文切换 ubuntu中终端输入的命令一般都是使用英文输入。linux中英文的切换方式是使用键盘“shift”键来切换，也可以点击顶部菜单的输入法按钮进行切换。ubuntu自带的Sunpinyin中文输入法已经足够读者使用。 Ubuntu终端复制粘贴快捷键 在Ubuntu终端窗口中，复制粘贴的快捷键需要加上 shift，即粘贴是 ctrl+shift+v。 接着使用如下命令设置密码，可简单设置为 hadoop，按提示输入两次密码： 1sudo passwd hadoop Shell 命令 可为 hadoop 用户增加管理员权限，方便部署，避免一些对新手来说比较棘手的权限问题： 1sudo adduser hadoop sudo Shell 命令 最后注销当前用户（点击屏幕右上角的齿轮，选择注销），返回登陆界面。在登陆界面中选择刚创建的 hadoop 用户进行登陆。 更新apt用 hadoop 用户登录后，我们先更新一下 apt，后续我们使用 apt 安装软件，如果没更新可能有一些软件安装不了。按 ctrl+alt+t 打开终端窗口，执行如下命令： 1sudo apt-get update Shell 命令 若出现如下 “Hash校验和不符” 的提示，可通过更改软件源来解决。若没有该问题，则不需要更改。从软件源下载某些软件的过程中，可能由于网络方面的原因出现没法下载的情况，那么建议更改软件源。在学习Hadoop过程中，即使出现“Hash校验和不符”的提示，也不会影响Hadoop的安装。 Ubuntu更新软件源时遇到Hash校验和不符的问题 点击查看：如何更改软件源 后续需要更改一些配置文件，我比较喜欢用的是 vim（vi增强版，基本用法相同），建议安装一下（如果你实在还不会用 vi/vim 的，请将后面用到 vim 的地方改为 gedit，这样可以使用文本编辑器进行修改，并且每次文件更改完成后请关闭整个 gedit 程序，否则会占用终端）： 1sudo apt-get install vim Shell 命令 安装软件时若需要确认，在提示处输入 y 即可。 通过命令行安装软件 点击查看：vim简单操作指南 安装SSH、配置SSH无密码登陆集群、单节点模式都需要用到 SSH 登陆（类似于远程登陆，你可以登录某台 Linux 主机，并且在上面运行命令），Ubuntu 默认已安装了 SSH client，此外还需要安装 SSH server： 1sudo apt-get install openssh-server Shell 命令 安装后，可以使用如下命令登陆本机： 1ssh localhost Shell 命令 此时会有如下提示(SSH首次登陆提示)，输入 yes 。然后按提示输入密码 hadoop，这样就登陆到本机了。 SSH首次登陆提示 但这样登陆是需要每次输入密码的，我们需要配置成SSH无密码登陆比较方便。 首先退出刚才的 ssh，就回到了我们原先的终端窗口，然后利用 ssh-keygen 生成密钥，并将密钥加入到授权中： 1exit # 退出刚才的 ssh localhostcd ~/.ssh/ # 若没有该目录，请先执行一次ssh localhostssh-keygen -t rsa # 会有提示，都按回车就可以cat ./id_rsa.pub &gt;&gt; ./authorized_keys # 加入授权 Shell 命令 ~的含义 在 Linux 系统中，~ 代表的是用户的主文件夹，即 “/home/用户名” 这个目录，如你的用户名为 hadoop，则 ~ 就代表 “/home/hadoop/”。 此外，命令中的 # 后面的文字是注释，只需要输入前面命令即可。 此时再用 ssh localhost 命令，无需输入密码就可以直接登陆了，如下图所示。 SSH无密码登录 安装Java环境Java环境可选择 Oracle 的 JDK，或是 OpenJDK，按中说的，新版本在 OpenJDK 1.7 下是没问题的。为图方便，这边直接通过命令安装 OpenJDK 7。下面有两种安装JDK的方式，可以任选一种，如果第1种失败，就选择第2种。推荐直接使用第2种安装方式。（1）第1种安装JDK方式： 1sudo apt-get install openjdk-7-jre openjdk-7-jdk Shell 命令 安装好 OpenJDK 后，需要找到相应的安装路径，这个路径是用于配置 JAVA_HOME 环境变量的。执行如下命令： 1dpkg -L openjdk-7-jdk | grep '/bin/javac' Shell 命令 该命令会输出一个路径，除去路径末尾的 “/bin/javac”，剩下的就是正确的路径了。如输出路径为 /usr/lib/jvm/java-7-openjdk-amd64/bin/javac，则我们需要的路径为 /usr/lib/jvm/java-7-openjdk-amd64。 接着需要配置一下 JAVA_HOME 环境变量，为方便，我们在 ~/.bashrc 中进行设置（扩展阅读: 设置Linux环境变量的方法和区别）： 1vim ~/.bashrc Shell 命令 在文件最前面添加如下单独一行（注意 = 号前后不能有空格），将“JDK安装路径”改为上述命令得到的路径，并保存： 1export JAVA_HOME=JDK安装路径 Shell 如下图所示（该文件原本可能不存在，内容为空，这不影响）： 配置JAVA_HOME变量 接着还需要让该环境变量生效，执行如下代码： 1source ~/.bashrc # 使变量设置生效 Shell 命令 设置好后我们来检验一下是否设置正确： 1echo $JAVA_HOME # 检验变量值java -version$JAVA_HOME/bin/java -version # 与直接执行 java -version 一样 Shell 命令 如果设置正确的话，$JAVA_HOME/bin/java -version 会输出 java 的版本信息，且和 java -version 的输出结果一样，如下图所示： 成功配置JAVA_HOME变量 这样，Hadoop 所需的 Java 运行环境就安装好了。 （2）第2种安装JDK方式根据大量电脑安装Java环境的情况我们发现，部分电脑按照上述的第一种安装方式会出现安装失败的情况，这时，可以采用这里介绍的另外一种安装方式，命令如下： 1sudo apt-get install default-jre default-jdk Shell 命令 上述安装过程需要访问网络下载相关文件，请保持联网状态。安装结束以后，需要配置JAVA_HOME环境变量，请在Linux终端中输入下面命令打开当前登录用户的环境变量配置文件.bashrc： 1vim ~/.bashrc Shell 命令 在文件最前面添加如下单独一行（注意，等号“=”前后不能有空格），然后保存退出： 1export JAVA_HOME=/usr/lib/jvm/default-java 接下来，要让环境变量立即生效，请执行如下代码： 1source ~/.bashrc # 使变量设置生效 Shell 命令 执行上述命令后，可以检验一下是否设置正确： 1echo $JAVA_HOME # 检验变量值java -version$JAVA_HOME/bin/java -version # 与直接执行java -version一样 Shell 命令 至此，就成功安装了Java环境。下面就可以进入Hadoop的安装。 安装 Hadoop 2Hadoop 2 可以通过 http://mirror.bit.edu.cn/apache/hadoop/common/ 或者 http://mirrors.cnnic.cn/apache/hadoop/common/ 下载，一般选择下载最新的稳定版本，即下载 “stable” 下的 hadoop-2.x.y.tar.gz 这个格式的文件，这是编译好的，另一个包含 src 的则是 Hadoop 源代码，需要进行编译才可使用。 截止到2015年12月9日，Hadoop官方网站已经更新到2.7.1版本。对于2.6.0以上版本的Hadoop，仍可以参照此教程学习，可放心下载官网最新版本的Hadoop。 如果读者是使用虚拟机方式安装Ubuntu系统的用户，请用虚拟机中的Ubuntu自带firefox浏览器访问本指南，再点击下面的地址，才能把hadoop文件下载虚拟机ubuntu中。请不要使用Windows系统下的浏览器下载，文件会被下载到Windows系统中，虚拟机中的Ubuntu无法访问外部Windows系统的文件，造成不必要的麻烦。 如果读者是使用双系统方式安装Ubuntu系统的用户，请进去Ubuntu系统，在Ubuntu系统打开firefox浏览器访问本指南，再点击下面的地址下载：hadoop-2.7.1下载地址 下载完 Hadoop 文件后一般就可以直接使用。但是如果网络不好，可能会导致下载的文件缺失，可以使用 md5 等检测工具可以校验文件是否完整。 点击查看：如何校验下载的文件是否完整 我们选择将 Hadoop 安装至 /usr/local/ 中： 1sudo tar -zxf ~/下载/hadoop-2.6.0.tar.gz -C /usr/local # 解压到/usr/local中cd /usr/local/sudo mv ./hadoop-2.6.0/ ./hadoop # 将文件夹名改为hadoopsudo chown -R hadoop ./hadoop # 修改文件权限 Shell 命令 Hadoop 解压后即可使用。输入如下命令来检查 Hadoop 是否可用，成功则会显示 Hadoop 版本信息： 1cd /usr/local/hadoop./bin/hadoop version Shell 命令 相对路径与绝对路径 请务必注意命令中的相对路径与绝对路径，本文后续出现的 ./bin/...，./etc/... 等包含 ./ 的路径，均为相对路径，以 /usr/local/hadoop 为当前目录。例如在 /usr/local/hadoop 目录中执行 ./bin/hadoop version 等同于执行 /usr/local/hadoop/bin/hadoop version。可以将相对路径改成绝对路径来执行，但如果你是在主文件夹 ~ 中执行 ./bin/hadoop version，执行的会是 /home/hadoop/bin/hadoop version，就不是我们所想要的了。 Hadoop单机配置(非分布式)Hadoop 默认模式为非分布式模式（本地模式），无需进行其他配置即可运行。非分布式即单 Java 进程，方便进行调试。 现在我们可以执行例子来感受下 Hadoop 的运行。Hadoop 附带了丰富的例子（运行 ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-2.6.0.jar 可以看到所有例子），包括 wordcount、terasort、join、grep 等。 在此我们选择运行 grep 例子，我们将 input 文件夹中的所有文件作为输入，筛选当中符合正则表达式 dfs[a-z.]+ 的单词并统计出现的次数，最后输出结果到 output 文件夹中。 1cd /usr/local/hadoopmkdir ./inputcp ./etc/hadoop/*.xml ./input # 将配置文件作为输入文件./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep ./input ./output 'dfs[a-z.]+'cat ./output/* # 查看运行结果 Shell 命令 执行成功后如下所示，输出了作业的相关信息，输出的结果是符合正则的单词 dfsadmin 出现了1次 Hadoop单机模式运行grep的输出结果 注意，Hadoop 默认不会覆盖结果文件，因此再次运行上面实例会提示出错，需要先将 ./output 删除。 1rm -r ./output Shell 命令 Hadoop伪分布式配置Hadoop 可以在单节点上以伪分布式的方式运行，Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也作为 DataNode，同时，读取的是 HDFS 中的文件。 Hadoop 的配置文件位于 /usr/local/hadoop/etc/hadoop/ 中，伪分布式需要修改2个配置文件 core-site.xml 和 hdfs-site.xml 。Hadoop的配置文件是 xml 格式，每个配置以声明 property 的 name 和 value 的方式来实现。 修改配置文件 core-site.xml (通过 gedit 编辑会比较方便: gedit ./etc/hadoop/core-site.xml)，将当中的 1&lt;configuration&gt;&lt;/configuration&gt; XML 修改为下面配置： 1&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; XML 同样的，修改配置文件 hdfs-site.xml： 1&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; XML Hadoop配置文件说明 Hadoop 的运行方式是由配置文件决定的（运行 Hadoop 时会读取配置文件），因此如果需要从伪分布式模式切换回非分布式模式，需要删除 core-site.xml 中的配置项。 此外，伪分布式虽然只需要配置 fs.defaultFS 和 dfs.replication 就可以运行（官方教程如此），不过若没有配置 hadoop.tmp.dir 参数，则默认使用的临时目录为 /tmp/hadoo-hadoop，而这个目录在重启时有可能被系统清理掉，导致必须重新执行 format 才行。所以我们进行了设置，同时也指定 dfs.namenode.name.dir 和 dfs.datanode.data.dir，否则在接下来的步骤中可能会出错。 配置完成后，执行 NameNode 的格式化: 1./bin/hdfs namenode -format Shell 命令 成功的话，会看到 “successfully formatted” 和 “Exitting with status 0” 的提示，若为 “Exitting with status 1” 则是出错。 执行namenode格式化 如果在这一步时提示 Error: JAVA_HOME is not set and could not be found. 的错误，则说明之前设置 JAVA_HOME 环境变量那边就没设置好，请按教程先设置好 JAVA_HOME 变量，否则后面的过程都是进行不下去的。如果已经按照前面教程在.bashrc文件中设置了JAVA_HOME，还是出现 Error: JAVA_HOME is not set and could not be found. 的错误，那么，请到hadoop的安装目录修改配置文件“/usr/local/hadoop/etc/hadoop/hadoop-env.sh”，在里面找到“export JAVA_HOME=${JAVA_HOME}”这行，然后，把它修改成JAVA安装路径的具体地址，比如，“export JAVA_HOME=/usr/lib/jvm/default-java”，然后，再次启动Hadoop。 接着开启 NameNode 和 DataNode 守护进程。 1./sbin/start-dfs.sh #start-dfs.sh是个完整的可执行文件，中间没有空格 Shell 命令 若出现如下SSH提示，输入yes即可。 启动Hadoop时的SSH提示 启动时可能会出现如下 WARN 提示：WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform… using builtin-java classes where applicable WARN 提示可以忽略，并不会影响正常使用。 启动 Hadoop 时提示 Could not resolve hostname 如果启动 Hadoop 时遇到输出非常多“ssh: Could not resolve hostname xxx”的异常情况，如下图所示： 启动Hadoop时的异常提示 这个并不是 ssh 的问题，可通过设置 Hadoop 环境变量来解决。首先按键盘的 ctrl + c 中断启动，然后在 ~/.bashrc 中，增加如下两行内容（设置过程与 JAVA_HOME 变量一样，其中 HADOOP_HOME 为 Hadoop 的安装目录）： 1export HADOOP_HOME=/usr/local/hadoopexport HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native Shell 保存后，务必执行 source ~/.bashrc 使变量设置生效，然后再次执行 ./sbin/start-dfs.sh 启动 Hadoop。 启动完成后，可以通过命令 jps 来判断是否成功启动，若成功启动则会列出如下进程: “NameNode”、”DataNode” 和 “SecondaryNameNode”（如果 SecondaryNameNode 没有启动，请运行 sbin/stop-dfs.sh 关闭进程，然后再次尝试启动尝试）。如果没有 NameNode 或 DataNode ，那就是配置不成功，请仔细检查之前步骤，或通过查看启动日志排查原因。 通过jps查看启动的Hadoop进程 Hadoop无法正常启动的解决方法 一般可以查看启动日志来排查原因，注意几点： 启动时会提示形如 “DBLab-XMU: starting namenode, logging to /usr/local/hadoop/logs/hadoop-hadoop-namenode-DBLab-XMU.out”，其中 DBLab-XMU 对应你的机器名，但其实启动日志信息是记录在 /usr/local/hadoop/logs/hadoop-hadoop-namenode-DBLab-XMU.log 中，所以应该查看这个后缀为 .log 的文件； 每一次的启动日志都是追加在日志文件之后，所以得拉到最后面看，对比下记录的时间就知道了。 一般出错的提示在最后面，通常是写着 Fatal、Error、Warning 或者 Java Exception 的地方。 可以在网上搜索一下出错信息，看能否找到一些相关的解决方法。 此外，若是 DataNode 没有启动，可尝试如下的方法（注意这会删除 HDFS 中原有的所有数据，如果原有的数据很重要请不要这样做）： 1# 针对 DataNode 没法启动的解决方法./sbin/stop-dfs.sh # 关闭rm -r ./tmp # 删除 tmp 文件，注意这会删除 HDFS 中原有的所有数据./bin/hdfs namenode -format # 重新格式化 NameNode./sbin/start-dfs.sh # 重启 Shell 命令 成功启动后，可以访问 Web 界面 http://localhost:50070 查看 NameNode 和 Datanode 信息，还可以在线查看 HDFS 中的文件。 Hadoop的Web界面 运行Hadoop伪分布式实例上面的单机模式，grep 例子读取的是本地数据，伪分布式读取的则是 HDFS 上的数据。要使用 HDFS，首先需要在 HDFS 中创建用户目录： 1./bin/hdfs dfs -mkdir -p /user/hadoop Shell 命令 注意 教材《大数据技术原理与应用》的命令是以”./bin/hadoop dfs”开头的Shell命令方式，实际上有三种shell命令方式。\1. hadoop fs\2. hadoop dfs\3. hdfs dfs hadoop fs适用于任何不同的文件系统，比如本地文件系统和HDFS文件系统hadoop dfs只能适用于HDFS文件系统hdfs dfs跟hadoop dfs的命令作用一样，也只能适用于HDFS文件系统 接着将 ./etc/hadoop 中的 xml 文件作为输入文件复制到分布式文件系统中，即将 /usr/local/hadoop/etc/hadoop 复制到分布式文件系统中的 /user/hadoop/input 中。我们使用的是 hadoop 用户，并且已创建相应的用户目录 /user/hadoop ，因此在命令中就可以使用相对路径如 input，其对应的绝对路径就是 /user/hadoop/input: 1./bin/hdfs dfs -mkdir input./bin/hdfs dfs -put ./etc/hadoop/*.xml input Shell 命令 复制完成后，可以通过如下命令查看文件列表： 1./bin/hdfs dfs -ls input Shell 命令 伪分布式运行 MapReduce 作业的方式跟单机模式相同，区别在于伪分布式读取的是HDFS中的文件（可以将单机步骤中创建的本地 input 文件夹，输出结果 output 文件夹都删掉来验证这一点）。 1./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep input output 'dfs[a-z.]+' Shell 命令 查看运行结果的命令（查看的是位于 HDFS 中的输出结果）： 1./bin/hdfs dfs -cat output/* Shell 命令 结果如下，注意到刚才我们已经更改了配置文件，所以运行结果不同。 Hadoop伪分布式运行grep结果 我们也可以将运行结果取回到本地： 1rm -r ./output # 先删除本地的 output 文件夹（如果存在）./bin/hdfs dfs -get output ./output # 将 HDFS 上的 output 文件夹拷贝到本机cat ./output/* Shell 命令 Hadoop 运行程序时，输出目录不能存在，否则会提示错误 “org.apache.hadoop.mapred.FileAlreadyExistsException: Output directory hdfs://localhost:9000/user/hadoop/output already exists” ，因此若要再次执行，需要执行如下命令删除 output 文件夹: 1./bin/hdfs dfs -rm -r output # 删除 output 文件夹 Shell 命令 运行程序时，输出目录不能存在 运行 Hadoop 程序时，为了防止覆盖结果，程序指定的输出目录（如 output）不能存在，否则会提示错误，因此运行前需要先删除输出目录。在实际开发应用程序时，可考虑在程序中加上如下代码，能在每次运行时自动删除输出目录，避免繁琐的命令行操作： 1Configuration conf = new Configuration();Job job = new Job(conf); /* 删除输出目录 */Path outputPath = new Path(args[1]);outputPath.getFileSystem(conf).delete(outputPath, true); Java 若要关闭 Hadoop，则运行 1./sbin/stop-dfs.sh Shell 命令 注意 下次启动 hadoop 时，无需进行 NameNode 的初始化，只需要运行 ./sbin/start-dfs.sh 就可以！ YARNYARN 是 Hadoop 2.x 中的内容，使用林子雨编写的大数据技术原理与应用教材的读者，可不用学习YARN内容。 如果对这方便的内容感兴趣，可点击下方查看。 点击查看：启动YARN 自此，你已经掌握 Hadoop 的配置和基本使用了。安装好的Hadoop项目中已经包含了第三章的HDFS，继续学习第3章HDFS文件系统，请参考如下学习指南：大数据技术原理与应用 第三章 学习指南 附加教程: 配置PATH环境变量在这里额外讲一下 PATH 这个环境变量（可执行 echo $PATH 查看，当中包含了多个目录）。例如我们在主文件夹 ~ 中执行 ls 这个命令时，实际执行的是 /bin/ls 这个程序，而不是 ~/ls 这个程序。系统是根据 PATH 这个环境变量中包含的目录位置，逐一进行查找，直至在这些目录位置下找到匹配的程序（若没有匹配的则提示该命令不存在）。 上面的教程中，我们都是先进入到 /usr/local/hadoop 目录中，再执行 sbin/hadoop，实际上等同于运行 /usr/local/hadoop/sbin/hadoop。我们可以将 Hadoop 命令的相关目录加入到 PATH 环境变量中，这样就可以直接通过 start-dfs.sh 开启 Hadoop，也可以直接通过 hdfs 访问 HDFS 的内容，方便平时的操作。 同样我们选择在 ~/.bashrc 中进行设置（vim ~/.bashrc，与 JAVA_HOME 的设置相似），在文件最前面加入如下单独一行: 1export PATH=$PATH:/usr/local/hadoop/sbin:/usr/local/hadoop/bin 添加后执行 source ~/.bashrc 使设置生效，生效后，在任意目录中，都可以直接使用 hdfs 等命令了，读者不妨现在就执行 hdfs dfs -ls input 查看 HDFS 文件试试看。 安装Hadoop集群在平时的学习中，我们使用伪分布式就足够了。如果需要安装 Hadoop 集群，请查看Hadoop集群安装配置教程。 相关教程 使用Eclipse编译运行MapReduce程序: 使用 Eclipse 可以方便的开发、运行 MapReduce 程序，还可以直接管理 HDFS 中的文件。 使用命令行编译打包运行自己的MapReduce程序: 有时候需要直接通过命令来编译、打包 MapReduce 程序。 参考资料 http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html http://www.cnblogs.com/xia520pi/archive/2012/05/16/2503949.html http://www.micmiu.com/bigdata/hadoop/hadoop-2x-ubuntu-build/]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是大数据]]></title>
    <url>%2F2018%2F09%2F27%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[概述根据IBM前首席执行官郭士纳的观点，IT领域每隔十五年就会迎来一次重大变革。 物联网改变了数据产生的方式，迎来了大数据时代。 大数据时代的技术支撑：存储、计算、网络能力的大幅提升。 大数据的四个特性：4V 数据量大：大数据摩尔定律、人类在最近两年产生的数据量相当于之前产生的全部数据量； 数据类型多：大数据是由结构化数据和非结构化数据组成，90%都是非结构化数据，结构化数据是存储在关系型数据库中的数据。 数据处理速度快 数据价值密度低，商业价值高 大数据的影响Jim Gray博士，98年图灵奖得主，提出了事务理论 四种研究方式： 实验，通过实验解决科学问题。 理论 计算 数据，以数据为驱动的全新的科学研究时代。通过对大量数据的分析找出问题。考数据驱动，发现问题，解决问题。 在思维方式方面大数据完全颠覆了传统的思维方式 全样而非抽样，不需要像以前一样做抽样 效率而非精确，因为以前是做抽样分析，所以要最前高精确度，使误差尽量小。大数据时代是对全样分析，不纯在误差放大问题，就不需要最求精确度，所以这时候追求的是效率。 相关而非因果，大数据时代只关注相关性，而不关注因果性。 大数据关键技术两大核心技术： 分布式存储：解决海量数据的存储问题 分布式处理：解决海量数据的处理问题 大数据技术一谷歌公司技术为代表 分布式数据库Big Table 分布式文件系统GFS 分布式并行处理技术MapReduce 不同的计算模式需要使用不同的产品 大数据产品服务的计算模式是不一样的，有些是用于批处理，有些是用于实时计算，有些是用于交互式计算。 批处理计算： 解决问题：针对大规模数据的批量处理 MapReduce是批处理计算模式的典型代表，适用于批处理，不适用于实时计算 15年异军突起的产品Spark，实时性比MapReduce更好，而且它解决了MapReduce当中的一些缺点，MapReduce无法高效的执行迭代计算，但是Spark可以进行迭代计算。许多应用中需要做迭代计算，比如数据挖掘，这时就不能用MapReduce要用Spark 流计算： 解决问题：针对流数据的实时计算 流计算是专门针对流数据的实时计算，流数据需要实时处理，给出实时响应，否则分析结果就会失去商业价值，只能用流计算框架进行处理，它是实现秒级的针对实时数据流的响应。 流计算代表产品：S4，Storm，Flume 图计算： 解决问题：针对大规模图结构数据的处理 图计算代表软件：Google Pregel 社交网络数据就是图结构数据 查询分析计算： 解决问题：大规模数据的存储管理和查询分析 大数据查询分析软件，满足交互式查询分析、 代表产品：Google Dremel，Hive，Cassandra，Impala 云计算 云计算解决两大核心问题： 分布式存储 分布式处理 云计算电信特征： 虚拟化 多租户 云计算的概念：云计算是通过网络以服务的方式为用户提供非常廉价的IT资源 云计算的优势：企业不需要自建IT基础设施，可以租用云端资源 云计算的三种模式： 公有云：百度云 私有云 混合云 自底向上的三种服务： IaaS 将基础设施（计算资源和存储）作为服务出租，如弹性云计算EC2 面向网络架构师 PaaS 平台即服务，云计算环境的开发平台 面向应用开发者 SaaS 典型案例：云财务软件 云计算的关键技术： 虚拟化， 多租户，云计算同时为多个用户服务 云计算数据中心 物联网 物联网层次架构：感知层，网络层，处理层，应用层 物联网的关键技术： 识别技术 感知技术]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】hexo框架基于next主题定制]]></title>
    <url>%2F2018%2F09%2F06%2F%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91hexo%E6%A1%86%E6%9E%B6%E5%9F%BA%E4%BA%8Enext%E4%B8%BB%E9%A2%98%E5%AE%9A%E5%88%B6%2F</url>
    <content type="text"><![CDATA[hexo框架基于next主题深度定制方案 主要有： 在右上角或者左上角实现fork me on github 添加RSS 背景配置 添加动态背景 实现点击出现桃心效果 修改文章内链接文本样式 修改文章底部的那个带#号的标签 在每篇文章末尾统一添加“本文结束”标记 修改作者头像并旋转 博文压缩 修改“代码块自定义样式 侧边栏社交小图标设置 主页文章添加阴影效果 在网站底部加上访问量 添加热度 网站底部字数统计 添加 README.md 文件 设置网站的图标Favicon 实现统计功能 添加顶部加载条 在文章底部增加版权信息 添加Gitment评论系统 隐藏网页底部powered By Hexo / 强力驱动 修改网页底部的桃心 文章加密访问 添加jiathis分享 博文置顶 修改字体大小 修改打赏字体不闪动 侧边栏推荐阅读 自定义鼠标样式 hexo 添加百度站长推送 hexo NexT主题首页title链接的优化 Hexo NexT主题修改文章标题样式 hexo 添加百度站长推送 在右上角或者左上角实现fork me on github具体实现方法点击这里 挑选自己喜欢的样式，并复制代码。 例如，我是复制如下代码： 然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中放在 1&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt; 的下面，并把href改为你的github地址 添加RSS具体实现方法切换到你的blog的路径，例如我是在/Users/Hexo/blog这个路径上，也就是在你的根目录下 然后安装 Hexo 插件：(这个插件会放在node_modules这个文件夹里) 1$ npm install --save hexo-generator-feed 接下来打开配置文件 在里面的末尾添加：(请注意在冒号后面要加一个空格，不然会发生错误！) 123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 然后打开next主题文件夹里面的_config.yml,在里面配置为如下样子：(就是在rss:的后面加上/atom.xml,注意在冒号后面要加一个空格) 1234# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 配置完之后运行：$ hexo g 重新生成一次，你会在./public 文件夹中看到 atom.xml 文件。然后启动服务器查看是否有效，之后再部署到 Github 中。 背景配置背景透明 博客根目录 themes\next\source\css_schemes\Pisces_layout.styl这个文件的第65行background:删除掉 按钮背景 博客根目录 themes\next\source\css_common\components\post\post-button.styl 第七行修 background: ; 站点概况背景 博客根目录 themes\next\source\css_schemes\Pisces_sidebar.styl 菜单栏背景 next\source\css_schemes\Pisces_layout.styl 文件里.header-inner 这个选择器下的background 就是背景色 添加动态背景具体实现方法修改代码 打开next/layout/_layout.swig，在之前添加如下代码： 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 修改主题配置文件 打开/next/_config.yml，添加以下代码： 123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 运行hexo clean 和 hexo g hexo s之后就可以看到效果了 实现点击出现桃心效果具体实现方法点击这里love.js 然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 修改文章内链接文本样式具体实现方法修改文件 themes\next\source\css_common\components\post\post.styl，在末尾添加如下css样式，： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择.post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 修改文章底部的那个带#号的标签具体实现方法修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成 1&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 在每篇文章末尾统一添加“本文结束”标记具体实现方法在路径 \themes\next\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）： 代码如下： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件（_config.yml),在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。 修改作者头像并旋转具体实现方法 打开\themes\next\source\css_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 博文压缩在站点的根目录下执行以下命令： 12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在如下图所示，新建 gulpfile.js ，并填入以下内容： 123456789101112131415161718192021222324252627282930313233var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);// 压缩 public 目录 cssgulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public 目录 htmlgulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩 public/js 目录 jsgulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 执行 gulp 命令时执行的任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;]); 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 修改“代码块自定义样式具体实现方法打开\themes\next\source\css_custom\custom.styl,向里面加入：(颜色可以自己定义) 123456789101112131415// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 侧边栏社交小图标设置具体实现方法打开主题配置文件（_config.yml），搜索social_icons:,在图标库找自己喜欢的小图标，并将名字复制在如下位置，保存即可 主页文章添加阴影效果具体实现方法打开\themes\next\source\css_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 在网站底部加上访问量具体实现方法打开\themes\next\layout_partials\footer.swig文件,在copyright前加上画红线这句话： 代码如下： 1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 然后再合适的位置添加显示统计的代码，如图： 代码如下： 12345&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 在这里有两中不同计算方式的统计代码： pv的方式，单个用户连续点击n篇文章，记录n次访问量 123&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; uv的方式，单个用户连续点击n篇文章，只记录1次访客数 123&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 添加之后再执行hexo d -g，然后再刷新页面就能看到效果 添加热度具体实现方法next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig,在画红线的区域添加℃： 然后打开，/themes/next/languages/zh-Hans.yml,将画红框的改为热度就可以了 网站底部字数统计具体方法实现切换到根目录下，然后运行如下代码 1$ npm install hexo-wordcount --save 然后在/themes/next/layout/_partials/footer.swig文件尾部加上： 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 添加 README.md 文件每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml，将 skip_render 参数的值设置为skip_render: README.md 保存退出即可。再次使用 hexo d 命令部署博客的时候就不会在渲染 README.md 这个文件了。 设置网站的图标Favicon具体方法实现在EasyIcon中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改主题配置文件：# Put your favicon.ico into hexo-site/source/ directory.favicon: /favicon.ico 实现统计功能具体实现方法在根目录下安装 hexo-wordcount,运行： 1$ npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下： 123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 添加顶部加载条具体实现方法打开/themes/next/layout/_partials/head.swig文件，添加红框上的代码 代码如下： 12&lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 目前，博主的增加顶部加载条的pull request 已被Merge现在升级最新版的next主题，升级后只需修改主题配置文件(_config.yml)将pace: false改为pace: true就行了，你还可以换不同样式的加载条. 在文章底部增加版权信息在目录 next/layout/_macro/下添加 my-copyright.swig： 1234567891011121314151617181920212223242526272829303132&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css&quot;&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); clipboard.on(&apos;success&apos;, $(function()&#123; $(&quot;.fa-clipboard&quot;).click(function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, html: false, timer: 500, showConfirmButton: false &#125;); &#125;); &#125;)); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;wechat-subscriber.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 如下： 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import &quot;my-post-copyright&quot; 保存重新生成即可。如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加 copyright: true 的设置，类似：小技巧：如果你觉得每次都要输入 copyright: true 很麻烦的话,那么在 /scaffolds/post.md 文件中添加： 这样每次hexo new “你的内容”之后，生成的md文件会自动把copyright:加到里面去(注意：如果解析出来之后，你的原始链接有问题：如：http://yoursite.com/前端小项目：使用canvas绘画哆啦A梦.html,那么在根目录下_config.yml中写成类似这样：）就行了。 添加Gitment评论系统具体实现方法见 为 hexo NexT 添加 Gitment 评论插件 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。 修改网页底部的桃心还是打开themes/next/layout/_partials/footer.swig，找到：，然后还是在图标库中找到你自己喜欢的图标，然后修改画红线的部分就可以了。 文章加密访问具体实现方法打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在以下位置插入这样一段代码： 代码如下： 12345678910&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 添加jiathis分享在主题配置文件中，jiathis为true，就行了，如下图 默认是这样子的： 如果你想自定义话，打开themes/next/layout/_partials/share/jiathis.swig修改画红线部分就可以了 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如 12345678---title: 解决Charles乱码问题date: 2017-05-22 22:45:48tags: 技巧categories: 技巧copyright: truetop: 100--- 修改字体大小打开\themes\next\source\css_variables\base.styl文件，将 $font-size-base改成16px ，如下所示： 1$font-size-base = 16px 修改打赏字体不闪动修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下： 123456789101112/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 侧边栏推荐阅读打开主题配置文件修改成这样就行了(links里面写你想要的链接): 1234567891011# Blogrollslinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: 优设: http://www.uisdc.com/ 张鑫旭: http://www.zhangxinxu.com/ Web前端导航: http://www.alloyteam.com/nav/ 前端书籍资料: http://www.36zhen.com/t?id=3448 百度前端技术学院: http://ife.baidu.com/ google前端开发基础: http://wf.uisdc.com/cn/ 自定义鼠标样式打开themes/next/source/css/_custom/custom.styl,在里面写下如下代码 1234567// 鼠标样式 * &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword2.ico&quot;),auto!important &#125; :active &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword1.ico&quot;),auto!important &#125; 其中 url 里面必须是 ico 图片，ico 图片可以上传到网上（我是使用七牛云图床），然后获取外链，复制到 url 里就行了 hexo 添加百度站长推送具体实现方法见 hexo 添加百度站长推送 hexo NexT主题首页title链接的优化具体实现方法见 hexo NexT主题首页title链接的优化 Hexo NexT主题修改文章标题样式进入主题目录 hexo\themes\next\source\css_common\components\post 修改post.styl文件，在配置的后面添加下面的代码。该文件是博文的样式表。 注意如果想把主页标题样式一同修改，可以用把 .page-post-detail 去掉 123456789101112131415161718192021/*添加下面的CSS代码来修改博客标题样式*/.page-post-detail .post-title &#123; font-size: 26px; text-align: center; word-break: break-word; font-weight: $posts-expand-title-font-weight background-color: #b9d3ee; border-radius:.3em; line-height:1em; padding-bottom:.12em; padding-top:.12em; box-shadow:2px 2px 7px #9fb6cd; +mobile() &#123; font-size: 22px; &#125;&#125;/*添加上面的CSS代码来修改博客标题样式*/@import &quot;post-expand&quot;;@import &quot;post-collapse&quot;;@import &quot;post-type&quot;;@import &quot;post-title&quot;; hexo 添加百度站长推送主动推送 自动推送，sitemap推送 本文转载自Hunter-Zack]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1936年9月竺可桢校长在浙大开学典礼上的讲话]]></title>
    <url>%2F2018%2F09%2F05%2F1936%E5%B9%B49%E6%9C%88%E7%AB%BA%E5%8F%AF%E6%A1%A2%E6%A0%A1%E9%95%BF%E5%9C%A8%E6%B5%99%E5%A4%A7%E5%BC%80%E5%AD%A6%E5%85%B8%E7%A4%BC%E4%B8%8A%E7%9A%84%E8%AE%B2%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[诸位同学，学校开课已一周，今天训育处召集这个会，能如家人似的在一起谈话，觉得非常愉快。 大学生，是人生最快活的时期，没有直接的经济负担，没有谋生的问题。诸位在中学中，同学大都是同县或同省，可是，来大学后，有从全国各方面来的同学，可以知道全国的情形，时间长了，各人都认识。这样，各人家庭的状况，故乡的风物，都能互相知道，这亦是一种教育。大学比之中学，在经费和设备方面，都来的充实，教师的经验和学识，也远胜于中学，这供给诸位切磋学问的极好机会。同时，国家花在诸位身上的钱，每年有一千五百元，而且，全中国大学生仅四万人，诸位都是这一万分之一的青年，这种机会，万万不能错过。 诸位到这里来，应该明了这里的校风。一校有一校的精神，英文称为College Spirit。至于浙大的精神，可以把“诚”、“勤”两字来表示。浙大的前身是求是书院和高等学堂，一脉相传，都可以诚勤两字代表它的学风，学生不浮夸，做事很勤恳，在社会上的声誉亦很好。有的学校校舍很好，可是毕业生做事，初出去就希望有物质的享受，待遇低一点便不愿做，房屋陋不愿住。浙大的毕业生便无此习惯，校外的人，碰见了，总是称赞浙大的风气朴实。这种风气，希望诸位把它保持。 诸位在校，有两个问题应该自己问问，第一，到浙大来做什么?第二，将来毕业后要做什么样的人?我想诸位中间，一定没有人说为文凭而到浙大来的，或者有的为到这里来是为了求一种技术，以做谋生的工具。但是，谋生之道很多，不一定到大学来，就是讲技术，亦不一定在大学。美国大文豪罗威尔氏说：“大学的目的，不在使学生得到面包，而在使所得到的面包味道更好。”教育不仅使学生谋得求生之道，单学一种技术，尚非教育最重要的目的。 这里我可以讲一个故事。中国古时有一个人求神仙心切，遍走名山大川。吕纯阳发慈悲，知道他诚心，想送给他一点金钱宝贝，向他说道，我的指头能指石为金，或任何物件，你要什么我便给你什么。可是那个人并不要金钱宝贝，而要他那只指头。这故事西洋也有的，英文所谓Wishing Ring，便是这个意思，要想什么就可得什么。世界上万事万物统有他存在的理由，朱子所谓格物致知就是即事而穷其理。要能即事而穷其理，最要紧的是一个清醒的头脑。 清醒的头脑，是事业成功的基础。两三年以后诸位出去，在社会上做一番事业，无论工农商学，都须有清醒的头脑。专精一门技术的人，头脑未必清楚。反之，头脑清楚，做学问办事业统行，我们国家到这步田地，完全靠头脑清醒的人才有救。凡是办一桩事或是研究一个问题，大致可分为以下三个步骤： 第一，以科学的方法来分析，使复杂的变成简单; 第二，以公正的态度来计划; 第三，以果断的决心来执行。 这三点，科学的方法，公正的态度，果断的决心，统应该在小学时代养成和学习的。中国历年来工商业的不振，科学的不进步，都是由于主持者没有清醒的头脑。瘟疫流行，水旱灾荒，连年叠见，仍旧还要靠拜忏求神扶乩种种迷信方法。兴办事业，毫无计划，都是吃了头脑不清楚的亏。风水扶乩算命求神等之为迷信，不但为近世科学家所诟病，即我国古代明理之君子亦早深悉而痛绝之。但到如今，大学毕业生和东西洋留学生中，受了环境的同化，而同流合污的很不少。大的企业如久大公司、永利公司和商务印书馆的成功，要算例外了。 近年来政府对社会所办的棉纱厂、面粉厂、硫酸厂、酒精厂和糖厂等，大多数是失败的。失败的原因或是由于调查的时候不用科学方法。譬如办糖厂，应在事先调查在该厂附近地域产多少甘蔗，出产的糖销至何处，成本的多少，赢利的厚薄，与夫国外倾销竞争的状况。若事先不调查清楚，后来必至蚀本倒闭。这类事在中国司空见惯，如汉口的造纸厂，梧州的硫酸厂，真不胜枚举。还有失败的原因是用人行政重情而不重理，这就是没有公正的态度。用人不完全以人才为标准，而喜欢滥用亲戚。每个机关、公司应该多聘专家，计划决定以后，外界无论如何攻击，都得照着计划做去，这样才能成功。 盲从的习惯，我们应该竭力避免，我们不能因为口号叫得响一点，或是主义新一点，就一唱百和的盲从起来。我们大家要静心平气的来观察口号的目的，主义的背景，凭我们的裁判，扪良心来决定我们的主张。若是对的，我们应竭力奉行。若是不对的我们应尽力排除。依违两可，明哲保身的态度，和盲从是一样要避免的。我们要做有主张有作为的人，这样就非有清醒之头脑不可。 现在，要问第二个问题，便是，离开大学以后，将来做什么样的人?我们的人生观应如何?有人认为中国的人生观很受孔孟的影响，实际影响最大的还是老子。孔孟主张见义勇为，老子主张明哲保身;孔孟主张正是非，老子主张明祸福。孟子说：“天之将降大任于斯人也，必先苦其心志，劳其筋骨”，诸葛亮“鞠躬尽瘁，死而后已”，这才不是享福哲学。老子说：“祸莫大于不知足”，又曰“祸兮福所倚，福兮祸所伏”。 中国一般人的最后目的还是享福。我们羡慕人家说某人福气好，娶媳妇进门，即祝之曰“多福多寿多男子”。就是生子的最大目的，也就是想年老的时候可以享福。中国普通人意想中的天堂，是可以不劳而获的一个世界，茶来开口，饭来伸手，这样享福哲学影响于民生问题很大。 人以享福为人生最大目的，中国民族必遭灭亡，历史上罗马之亡可为殷鉴。现在的世界是竞争的世界，如果一个民族还是一味以享受为目的，不肯以服务为目的，必归失败。我们应该以享福为可耻，只有老弱残废才能享福，而以自食其力为光荣。英国国王在幼年时，必在军舰充当小兵，惟其如此方能知兵士的疾苦。全世界最富的人是煤油大王洛克菲勒(Rockefeller)，他的儿子做事从小伙计做起，所以他们的事业能子孙相传不替。 多年前，中日同时派学生留学欧美，中国的学生，一看见各类机械，便问从何处购买?何处最便宜?而日本的学生，只问如何制造?中国人只知道买，以享受为目的，而日本人则重做，以服务为目的;中国从前学工学农的人，统是只叫工人农夫去推动机器，耕耘田亩，而自己却在一边袖手旁观，这样讲究农工业是不会进步的。中国古代轻视劳力，现在已经完全改变，样样应该自己动手，这种人生观的改造，是极重要的。 以上所说的两点：第一，诸位求学，应不仅在科目本身，而且要训练如何能正确地训练自己的思想;第二，我们人生的目的是在能服务，而不在享受。 ——刊于《国立浙江大学日刊》第20号（1936年9月23日）“讲演”栏]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为云图引擎服务实时推荐（Real-time Recommendation）算法]]></title>
    <url>%2F2018%2F09%2F05%2Fhuawei-real-time-recommendation%2F</url>
    <content type="text"><![CDATA[概述图引擎服务提供的实时推荐算法是一种基于随机游走模型的实时推荐算法，能够推荐与输入节点相近程度高、关系或喜好相近的节点。 实时推荐过程主要是基于对图上多起点“source”的随机游走：其根据各节点的重要性给各请求节点分配不同的游走步长， 同时对各请求节点进行随机游走，综合各起点随机游走下候选节点的得分结果，进行推荐。 其中，随机游走过程：从请求节点”source“沿着边，根据一定的倾向性不断地“游走“到相邻的节点，达到一定步数（步长）时返回起点重新游走。 游走步长：CurrSteps = SampleWalkLength(alpha)[1] 多次这样的游走后， 对于一个节点，如果其在随机游走过程被访问到，且被访问到的次数达到“nv”，则该节点将记入候选推荐的节点。若某个source节点的候选推荐节点达到“np”，对于该source节点的随机游走将提前结束，或者达到总的游走步数上限”N“时结束。 随机游走过程中，随着被经过的次数的增加，候选节点被推荐的得分也相应增加；当所有的随机游走结束时，系统将给出各候选节点的综合得分，得分越高被推荐的程度越大。 参数说明sources： 给定节点ID，点击”+”可添加多个节点，最多不超过30个。该参数必填。 alpha：权重系数, 其值越大步长越长, 取值范围（0~1）, 实数，默认值为0.85。 N：总的游走步数, [1,200000], 正整数，默认值10000。 nv：候选推荐节点所需访问次数的最小值, 取值范围(0,10], 正整数，默认值5。 np：游走过程提前结束参数：候选推荐节点个数。取值范围 [1,2000], 正整数，默认值1000。 label：希望输出的点的类型。其值为空时，将不考虑点的类型，输出算法原始计算结果。对其赋值时，将从计算结果中过滤出具有该“label”的点的返回。 directed：是否考虑边的方向。true 或false，布尔型。默认值true。 参数分析 sources 单个source 例如：“当Mike打开某电影平台，向其推荐电影“时，可以输入sources为Mike, label为movie，其他参数如下图（左），点击运行。页面画布上将会出现含有推荐节点的子图，大小反映了推荐程度。 多个sources 例如：“Leo的某个朋友，浏览了Leo主页，添加Steven Spielberg导演动态,为其进行电影推荐”，这时，我们可以输入参数如下图左，综合考虑这两种兴趣（“Leo”、“Steven Spielberg”）进行实时推荐： alpha alpha和N的值决定了总的游走步长。通过实验得知alpha的取值不应过小。当alpha取一个比较小的值（这里取的是0.3）时，推荐的结果中，得分从201过渡到34，如下图所示。而当alpha取一个较大值，例如0.85的时候就不会出现这种情况。 N 总的游走步数，当达到总的游走步数上限”N“时结束。控制程序何时结束。 nv 候选推荐节点所需访问次数的最小值。 对于一个节点，如果其在随机游走过程被访问到，且被访问到的次数达到“nv”，则该节点将记入候选推荐的节点。 np 若某个source节点的候选推荐节点达到“np”，对于该source节点的随机游走将提前结束。这是一个早停参数。如下图所示，当np=1000时，算法总耗时:0.0616 s，当np=10时，算法总耗时:0.0019 s。可知选择一个合适的np值可以减少耗时，提高效率。 label 控制输出的点的类型。 其值为空时，将不考虑点的类型，输出算法原始计算结果。 对其赋值时，将从计算结果中过滤出具有该“label”的点的返回。 directed 是否考虑边的方向。当directed=true时，可以看到结果画布中Leo节点的入度为0。 参考文献[1] Eksombatchai C, Jindal P, Liu J Z, et al. Pixie: A System for Recommending 3+ Billion Items to 200+ Million Users in Real-Time[J]. 2017.]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence</tag>
        <tag>华为云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO备忘]]></title>
    <url>%2F2018%2F09%2F04%2Fhexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[hexo常用命令预览访问 1hexo server 部署步骤 123hexo cleanhexo generatehexo deploy 为文章添加附件Hexo配置文件的设置确保你的Hexo的配置文件_config.yml里面有个这个选项配置，并将其置为true 1post_asset_folder: true 插入图片在 \source\_posts 建立一个md文件来写博客，同时建立一个同名的文件夹去存放资源。 1![图片描述](/文件夹/图片名.png)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The State of the Art in Semantic Representation]]></title>
    <url>%2F2018%2F08%2F02%2Fthe-state-of-the-art-in-semantic-repesentation%2F</url>
    <content type="text"><![CDATA[作者：Omri Abend and Ari Rappoport 这是一篇ACL2017的文章，是一篇语义表示方面的综述性论文。作者对当前一些最先进的语义表示方案以及资源（比如 AMR, UCCA, GMB, UDS)进行了一个survey。 概述语义表示在过去的几年中越来越受到人们的关注，并且发表了很多语义表示方面的文章（例如：AMR, UCCA, GMB, UDS）。但是这些文章中很少和句法方案进行比较，评估他们之间的优缺点，也没有清楚的阐明语义表示研究的总体目标。这篇文章通过语义表示领域的最先进的论文和技术进行了survey，填补了这项空白。 这篇文章可以分为四部分： 第一部分详细阐述了文本语义表示（SRT）的目的，作者将语义表示定义为将文本的意思映射为语言发言者所理解的语义表示。 第二部分对文本语义表示包含的主要内容进行了总结，语义表示的内容主要包括谓词论元关系（predicate-argument）、话语关系（discourse relations）和逻辑结构（logical structure）等。 第三部分详细介绍了当前最先进的SRT方案和注释资源，并且分别介绍了它们的评估标准以及与句法方案的比较。 第四部分进行了总结。 语义表示的定义（术语 semantics 在不同的上下文中会有不同意思。）在这篇论文中，作者将语义表示定义为将文本的意思映射为语言发言者(language speaker)所理解的语义表示。因此，语义表示可以看成是提取信息的方法，所提取出来的信息可以由语言发言者直接评估。 提取过程应该可靠且计算效率高。 一种方法是通过外部（文本外）标准或应用程序提取信息。比如支持推理的文本语义表示，推理出文本蕴涵或自然逻辑。 其他例子包括根据支持知识库查询定义语义表示等。 另一个SRT的方法是通过向量空间模型（VSM），从单词到短语和句子级别的所有语言元素建模为向量，它避免使用符号结构。 使用这种方法的通常会调用神经网络，在许多任务上获得优秀的结果，包括词汇任务，如跨语言单词相似度，机器翻译等。 语义内容SRTs的内容的基本组成成分是论元（argument）结构（谁对谁做了什么，何地，何时以及为什么）。换句话说就是事件（events），表示参与者和他们之间的关系。 我们将使用以下作为运行示例：(1) Although Ann was leaving, she gave the present to John. Events. 一个事件包括谓词，它是事件的主要决定因素。 事件还包括论元（参与者，核心元素）和次级关系（修饰符，非核心元素）。示例1通常被视为具有两个事件，由谓词“leaving”和“gave”引起。 Predicates and Arguments. 谓词论元关系被普遍认为是语义表示的基础。大多数语义角色标注（SRL）方案涵盖了各种各样的动词谓词，但不同之处在于他们是否涵盖了名词性谓词和形容词谓词。例如，PropBank（Palmer et al。，2005）是SRL的主要资源之一，涵盖动词，并且在其最新版本中也包括偶数名词和多论元形容词。 FrameNet（Ruppenhofer等，2016）涵盖了所有这些，但也包括不引起事件的关系名词，如“president”。 其他工作涉及出现在句子边界之外的语义参数，或者没有明确出现在文本中的任何地方（Gerber和Chai，2010; Roth和Frank，2015）。 Core and Non-core Arguments. 论元类型之间最常见的区别在于核心和非核心论元。虽然可以在必需论元和可选论元之间进行区别，但在这里我们关注语义维度，它区分了其含义是特定谓词的论元，并且是所描述事件（核心）的必要组成，以及一般谓词（非核心）。 Semantic Roles. 语义角色是论元的类别。 多年来已经在NLP中提出并使用了许多不同的语义角色库，最突出的是FrameNet，以及PropBank。 PropBank的角色集由AMR等后续项目扩展。 另一个突出的语义角色库是VerbNet和之后的项目，它们定义了一组封闭的抽象语义角色集合，适用于所有谓词论元。 Co-reference and Anaphora. 共指关系允许从引用相同实体的不同方式中抽象出来，并且通常包括在语义资源中。 Temporal Relations. NLP中的大多数时间语义工作都集中在事件之间的时间关系上，或者通过根据文本中找到的时间表达式对它们进行时间戳，或者通过预测它们在时间上的相对顺序。 重要资源包括TimeML，它是时间关系的规范语言，以及TempEval系列共享任务和注释语料库。与时间关系相关的是事件之间的因果关系，它们在语言中无处不在，并且是各种应用的核心。 Spatial Relations. 空间关系的表示在语义的认知理论中是关键的，并且在诸如地理信息系统或机器人导航的应用领域中是关键的。 该领域的重要任务包括空间角色标记，该任务包括空间元素和空间关系的识别和分类，例如地点，路径，方向和运动，以及它们的相对结构。 Discourse Relations 话语关系包含事件或更大的语义单元之间的任何语义关系。 例如，在（1）中，leaving和giving事件有时通过CONCESSION类型的话语关系相关，由“although”引起。 此类信息非常有用，通常对于各种NLP任务例如摘要，机器翻译和信息提取至关重要，但在开发此类系统时通常会被忽略。 Logical Structure. 逻辑结构是许多理论语言学中语义分析的基石，也在NLP领域引起了广泛关注。常见的表示通常基于谓词演算的变体，对于需要将文本映射到外部（通常是可执行的）形式语言的应用程序非常有用，例如查询语言或机器人指令。逻辑结构对于识别句子之间的蕴涵关系也很有用，因为一些蕴涵可以通过正式证明者从文本的逻辑结构中计算出来。 Inference and Entailment. 许多语义方案的主要动机是它们支持推理和蕴涵的能力。 语义方案和资源本节简要介绍了SRT的不同方案和资源。 Semantic Role Labeling. SRL方案通常被称为“浅层语义分析”，因为它们专注于论元结构，忽略了其他关系，如话语事件，或者谓词和论元是如何在内部构建的。 SRL方案在它们的事件类型，涵盖的谓词类型，粒度，跨语言适用性，组织原则以及它们与句法的关系方面有所不同。大多数SRL方案相对于某些语法结构定义它们的注释，例如在PropBank的情况下PTB的解析树，或者在FrameNet的情况下为SRL目的定义的专用语法类别。除了上面讨论的PropBank，FrameNet和VerbNet之外，其他值得关注的资源包括Semlink（Loper等，2007），它链接不同资源中的相应条目，如Prop-Bank，FrameNet，VerbNet和WordNet，以及Preposition Supersenses项目（Schneider et al。，2015），侧重于介词引发的角色。 AMR （抽象语义表示）涵盖谓词 - 论元关系，包括语义角色，它适用于各种谓词（包括言语，名词和形容词谓词），修饰词，共指关系，命名实体和一些时间表达。AMR目前不支持高于句子级别的关系到一个语义类别。并且是以英语中心，因此，在跨语言时，AMR面临着困难。 UCCA （通用概念认知注释）是一种跨语言适用的语义注释方案，建立在类型学理论的基础上，主要基于基础语言学理论。UCCA的基础层次侧重于各种类型的论元结构和它们之间的关系。其当前状态中，UCCA比上述方案更粗糙（例如，它不包括语义角色信息）。 然而，它的跨语言中得到很好的推广。UCCA另一个优点是支持非专家的注释。 UDS. Universal Decompositional Semantics 通用分解语义是一种多层方案，目前包括语义角色注释，词义和体类。 然而，UDS表示的骨架结构源自句法依赖性，并且仅包括动词论元结构。 The Prague Dependency Treebank (PDT) Tectogrammatical Layer (PDT-TL)涵盖了丰富的功能和语义差异，例如论元结构（包括语义角色）， 时态，省略号，主题/焦点，共指关系，词义消歧和方言信息。 PDT-TL源于对PDT语法层的抽象，其与语法的密切关系是显而易见的。 CCG-based Schemes. CCG是一种词汇化语法（即，几乎所有语义内容都在词典中编码），它定义了词汇信息如何组成以构成短语和句子含义的理论，并且在各种语义任务中被证明是有效的。 HPSG-based Schemes. 与基于CCG的方案相关的是基于Head-driven Phrase Structure Grammar的SRT，其中句法和语义特征被表示为特征束，其通过统一规则迭代地组成以形成复合单元。 基于HPSG的SRT方案通常使用Minimal Recursion Semantics形式化。 注释语料库和手工制作的语法存在多种语言，并且通常关注论元结构和逻辑语义现象。 OntoNotes 是一个有用的资源，具有多个相互关联的注释层，借用于不同的方案。 这些层包括句法，SRL，共指关系和词义消歧内容。 谓词的某些属性，例如哪些名词是偶数，也被编码。 总而言之，虽然SRT方案在它们支持的内容类型上有所不同，但方案不断发展以不断添加新的内容类型，从而使这些差异不那么重要。 这些方案之间的根本区别在于它们从语法中抽象出来的程度。 例如，AMR和UCCA从语法中抽象出来作为其设计的一部分，而在大多数其他方案中，句法法和语义更加紧密耦合。 评估人类评估是验证SRT方案的最终标准，因为我们将语义定义为语言发言者理解的意义。 确定SRT方案的理想程度是通过人类根据预先指定的要求对文本进行一些语义预测或注释，并将其与从SRT提取的信息进行比较。 另一种评估方法是基于任务的评估。NLP中的许多语义表示都是在考虑应用程序的情况下定义的，这使得这种评估方式显得更加自然。例如，AMR的一个主要动机是它对机器翻译的适用性，使MT成为AMR评估的一个自然（虽然迄今未开发）测试平台。 另一个例子是使用问答来评估基于知识查询中的语义解析。 评估语义方案的另一个常见标准是不变性（invariance），其中语义分析应该在释义或翻译对之间相似。 重要的是，这些评估标准也适用于自动引发表示而非手动定义的情况。 例如，通常通过基于任务的评估或者根据从它们计算的语义特征来评估向量空间表示，其有效性由人类注释者建立（例如，Agirre等人，2013,2014）。 最后，在通过手动注释（而不是通过自动化程序）引入语义方案的情况下，确定指南是否足够清晰以及类别是否定义明确的共同标准是通过为注释者指定一致来衡量注释者之间的一致性。 相同的文本和测量结果的相似性。 措施包括针对AMR的SMATCH测量（Cai和Knight，2013），以及适用于UCCA的DAG的PARSEVAL F-评分（Black等，1991）。 SRT方案在他们的注释者所需的背景和训练方面存在分歧。 一些方案需要广泛的训练（例如，AMR），而其他方案可以（至少部分地）通过众包（例如，UDS）来收集。 其他例子包括FrameNet，它需要专家注释者来创建新的事件，但是使用训练有素的内部注释器将现有的帧应用于文本; QASRL，远程使用非专家注释器; 和UCCA，它使用内部非专家，在初始培训期后证明对非专家注释器的专家没有优势。 GMB的另一种方法是使用在线协作，其中专家协作者参与手动纠正自动创建的表示。 他们进一步采用游戏化策略来收集注释的某些方面。 Universality. 语义分析（通过更多表面形式的分析）的巨大承诺之一是其跨语言潜力。 然而，尽管普遍性在语义学中的理论和应用重要性早已得到认可（Goddard，2011），但普遍语义学的本质仍然未知。 最近，诸如BabelNet（Ehrmann等人，2014），UBY（Gurevych等人，2012）和Open Multilingual Wordnet等项目构建了庞大的多语言语义网络，通过链接Wikipedia和WordNet等资源并使用现代NLP技术处理它们。 然而，此类项目目前侧重于词汇语义和百科全书信息，而不是文本语义。 诸如SRL方案和AMR之类的符号SRT方案也因其跨语言适用性而被研究（Pad’o和Lapata，2009; Sun等，2010; Xue等，2014），表明跨语言的部分可移植性。 已经为多种语言构建了PropBank和FrameNet的翻译版本（例如，Akbik等，2016; Hartmann和Gurevych，2013）。 然而，由于PropBank和FrameNet都是词汇化方案，并且由于词汇在跨语言中大相径庭，因此这些方案在跨语言移植时需要相当大的适应性（Kozhevnikov和Titov，2013）。 正在进行的研究解决了将VerbNet的非语言化角色概括为普遍适用的集合（例如，Schneider等，2015）。 很少有SRT方案将跨语言适用性作为其主要标准之一，例如UCCA和LinGO语法矩阵（Bender和Flickinger，2005），两者都借鉴了类型学理论。 在向量空间中嵌入单词和句子的向量空间模型也被用于引发共享的跨语言空间（Klementiev等，2012; Rajendran等，2015; Wu等，2016）。 然而，需要进一步评估以确定这些表示的可能含义的哪些方面可靠地反映。 结论NLP中的语义表示正在经历快速变化。 传统的语义工作要么使用侧重于特定语义现象的浅层方法，要么采用形式语义理论，这些理论通过语法 - 语义推理理论与句法方案相结合。 近年来，人们越来越关注一种独立于任何句法或分布标准定义语义结构的替代方法，这很大程度上归功于实现这种方法的语义树库的可用性。 语义方案在它们是否固定在文本的单词和短语(例如，所有类型的语义依赖关系和UCCA)中存在分歧(例如，AMR和基于逻辑的表示)。我们不认为这是一个主要的区别，因为大多数非雇定的表示(包括AMR)与句子中的单词保持着密切的亲和力，这可能是因为没有一个可行的词汇分解方案，而依赖结构可以转换成基于逻辑的表示(Reddy et al.， 2016)。在实践中，固定可以促进解析，而非锚定表示可以更灵活地使用不存在单词和语义组件的一一对应。 这篇论文总结了方案之间的主要区别因素是它们与句法方案之间的关系、它们的普遍性程度以及它们对注释者的专业知识的要求，这是解决注释瓶颈的一个重要因素。我们希望通过对语义表示的最先进的研究来促进研究者的讨论，使更多的研究人员接触到语义表示中最紧迫的问题。]]></content>
      <categories>
        <category>阅读笔记</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
  </entry>
</search>
